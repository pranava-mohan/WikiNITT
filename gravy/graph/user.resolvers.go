package graph

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.86

import (
	"context"
	"fmt"
	"os"
	"regexp"
	"time"

	"github.com/99designs/gqlgen/graphql"
	"github.com/pranava-mohan/wikinitt/gravy/graph/model"
	"github.com/pranava-mohan/wikinitt/gravy/internal/auth"
	"github.com/pranava-mohan/wikinitt/gravy/internal/sanitization"
	"github.com/pranava-mohan/wikinitt/gravy/internal/users"
	"golang.org/x/crypto/bcrypt"
)

// SignIn is the resolver for the signIn field.
func (r *mutationResolver) SignIn(ctx context.Context, input model.NewUser) (string, error) {
	if input.MachineToken != os.Getenv("MACHINE_TOKEN") {
		return "", fmt.Errorf("invalid machine token")
	}

	existingUser, err := r.UserRepo.GetByDauthID(ctx, input.ID)
	if err == nil && existingUser != nil {

		return auth.GenerateToken(existingUser.ID)
	}

	avatarURL, err := auth.AvatarGenerationAndCleanup(input.ID, r.Uploader)
	if err != nil {
		return "", fmt.Errorf("failed to generate avatar: %w", err)
	}

	defaultUsername := fmt.Sprintf("user_%s", input.ID)
	defaultDisplayName := input.Name

	user := users.User{
		DauthID:       input.ID,
		Name:          input.Name,
		Username:      defaultUsername,
		DisplayName:   defaultDisplayName,
		Email:         input.Email,
		Gender:        input.Gender,
		PhoneNumber:   input.PhoneNumber,
		CreatedAt:     time.Now(),
		IsAdmin:       false,
		IsBanned:      false,
		SetupComplete: false,
		Avatar:        avatarURL,
	}

	if err := r.UserRepo.Create(ctx, &user); err != nil {
		return "", fmt.Errorf("failed to create user: %w", err)
	}

	token, err := auth.GenerateToken(user.ID)
	if err != nil {
		return "", fmt.Errorf("failed to generate token: %w", err)
	}

	return token, nil
}

// Login is the resolver for the login field.
func (r *mutationResolver) Login(ctx context.Context, input model.LoginInput) (string, error) {
	user, err := r.UserRepo.GetByEmail(ctx, input.Email)
	if err != nil {
		return "", fmt.Errorf("invalid credentials")
	}

	err = bcrypt.CompareHashAndPassword([]byte(user.PasswordHash), []byte(input.Password))
	if err != nil {
		return "", fmt.Errorf("invalid credentials")
	}

	return auth.GenerateToken(user.ID)
}

// CompleteSetup is the resolver for the completeSetup field.
func (r *mutationResolver) CompleteSetup(ctx context.Context, input model.CompleteSetupInput) (string, error) {
	user := auth.ForContext(ctx)
	if user == nil {
		return "", fmt.Errorf("not authenticated")
	}

	usernameRegex := regexp.MustCompile(`^[a-zA-Z0-9_.-]+$`)
	if !usernameRegex.MatchString(input.Username) {
		return "", fmt.Errorf("username can only contain letters, numbers, underscores, periods, and hyphens")
	}

	displayNameRegex := regexp.MustCompile(`^[a-zA-Z0-9 ]+$`)
	if !displayNameRegex.MatchString(input.DisplayName) {
		return "", fmt.Errorf("display name can only contain letters, numbers, and spaces")
	}

	existingUser, err := r.UserRepo.GetByUsername(ctx, sanitization.SanitizeString(input.Username))
	if err == nil && existingUser != nil && existingUser.ID != user.ID {
		return "", fmt.Errorf("username already taken")
	}

	err = r.UserRepo.CompleteSetup(ctx, user.ID, sanitization.SanitizeString(input.Username), input.DisplayName)
	if err != nil {
		return "", fmt.Errorf("failed to complete setup: %w", err)
	}

	return "success", nil
}

// BlockUser is the resolver for the blockUser field.
func (r *mutationResolver) BlockUser(ctx context.Context, id string) (bool, error) {
	err := r.UserRepo.Block(ctx, id)
	if err != nil {
		return false, err
	}
	return true, nil
}

// UnblockUser is the resolver for the unblockUser field.
func (r *mutationResolver) UnblockUser(ctx context.Context, id string) (bool, error) {
	err := r.UserRepo.Unblock(ctx, id)
	if err != nil {
		return false, err
	}
	return true, nil
}

// UpdateUser is the resolver for the updateUser field.
func (r *mutationResolver) UpdateUser(ctx context.Context, input model.UpdateUserInput) (*model.User, error) {
	user := auth.ForContext(ctx)
	if user == nil {
		return nil, fmt.Errorf("not authenticated")
	}

	if input.Username != nil {
		usernameRegex := regexp.MustCompile(`^[a-zA-Z0-9_.-]+$`)
		if !usernameRegex.MatchString(*input.Username) {
			return nil, fmt.Errorf("username can only contain letters, numbers, underscores, periods, and hyphens")
		}

		existingUser, err := r.UserRepo.GetByUsername(ctx, *input.Username)
		if err == nil && existingUser != nil && existingUser.ID != user.ID {
			return nil, fmt.Errorf("username already taken")
		}
	}

	if input.DisplayName != nil {
		displayNameRegex := regexp.MustCompile(`^[a-zA-Z0-9 ]+$`)
		if !displayNameRegex.MatchString(*input.DisplayName) {
			return nil, fmt.Errorf("display name can only contain letters, numbers, and spaces")
		}
	}

	updates := make(map[string]interface{})
	if input.Username != nil {
		updates["username"] = sanitization.SanitizeString(*input.Username)
	}
	if input.DisplayName != nil {
		updates["display_name"] = *input.DisplayName
	}
	if input.Avatar != nil {
		updates["avatar"] = sanitization.SanitizeString(*input.Avatar)
	}

	if len(updates) == 0 {
		return mapUserToModel(user), nil
	}

	updatedUser, err := r.UserRepo.Update(ctx, user.ID, updates)
	if err != nil {
		return nil, fmt.Errorf("failed to update user: %w", err)
	}

	return mapUserToModel(updatedUser), nil
}

// UploadAvatar is the resolver for the uploadAvatar field.
func (r *mutationResolver) UploadAvatar(ctx context.Context, file graphql.Upload) (string, error) {
	user := auth.ForContext(ctx)
	if user == nil {
		return "", fmt.Errorf("not authenticated")
	}

	url, err := r.Uploader.UploadImage(ctx, file.File, "wikinitt/avatars")
	if err != nil {
		return "", fmt.Errorf("failed to upload avatar: %w", err)
	}
	return url, nil
}

// UploadUserImage is the resolver for the uploadUserImage field.
func (r *mutationResolver) UploadUserImage(ctx context.Context, file graphql.Upload) (string, error) {
	user := auth.ForContext(ctx)
	if user == nil {
		return "", fmt.Errorf("not authenticated")
	}

	url, err := r.Uploader.UploadImage(ctx, file.File, "wikinitt/user-uploads")
	if err != nil {
		return "", fmt.Errorf("failed to upload image: %w", err)
	}
	return url, nil
}

// Posts is the resolver for the posts field.
func (r *publicUserResolver) Posts(ctx context.Context, obj *model.PublicUser, limit *int32, offset *int32) ([]*model.Post, error) {
	l := 10
	o := 0
	if limit != nil {
		l = int(*limit)
	}
	if offset != nil {
		o = int(*offset)
	}

	posts, err := r.CommunityRepo.ListPublicPostsByAuthor(ctx, obj.ID, l, o)
	if err != nil {
		return nil, err
	}

	authorPublic := &users.PublicUser{
		ID:          obj.ID,
		Name:        obj.Name,
		Username:    obj.Username,
		DisplayName: obj.DisplayName,
		Gender:      obj.Gender,
		Avatar:      obj.Avatar,
	}

	var modelPosts []*model.Post
	for _, p := range posts {
		group, _ := r.CommunityRepo.GetGroupByID(ctx, p.GroupID)
		groupOwner, _ := r.UserRepo.GetByID(ctx, group.OwnerID)
		groupOwnerPublic := mapUserToPublic(groupOwner)
		modelPosts = append(modelPosts, mapPostToModel(p, authorPublic, group, groupOwnerPublic))
	}
	return modelPosts, nil
}

// Comments is the resolver for the comments field.
func (r *publicUserResolver) Comments(ctx context.Context, obj *model.PublicUser, limit *int32, offset *int32) ([]*model.Comment, error) {
	l := 10
	o := 0
	if limit != nil {
		l = int(*limit)
	}
	if offset != nil {
		o = int(*offset)
	}

	comments, err := r.CommunityRepo.ListPublicCommentsByAuthor(ctx, obj.ID, l, o)
	if err != nil {
		return nil, err
	}

	authorPublic := &users.PublicUser{
		ID:          obj.ID,
		Name:        obj.Name,
		Username:    obj.Username,
		DisplayName: obj.DisplayName,
		Gender:      obj.Gender,
		Avatar:      obj.Avatar,
	}

	var modelComments []*model.Comment
	for _, c := range comments {
		post, _ := r.CommunityRepo.GetPost(ctx, c.PostID)
		postAuthor, _ := r.UserRepo.GetByID(ctx, post.AuthorID)
		postAuthorPublic := mapUserToPublic(postAuthor)

		group, _ := r.CommunityRepo.GetGroupByID(ctx, post.GroupID)
		groupOwner, _ := r.UserRepo.GetByID(ctx, group.OwnerID)
		groupOwnerPublic := mapUserToPublic(groupOwner)

		modelComments = append(modelComments, mapCommentToModel(c, authorPublic, post, postAuthorPublic, group, groupOwnerPublic))
	}
	return modelComments, nil
}

// Users is the resolver for the users field.
func (r *queryResolver) Users(ctx context.Context) ([]*model.User, error) {
	users, err := r.UserRepo.List(ctx)
	if err != nil {
		return nil, err
	}
	var modelUsers []*model.User
	for _, u := range users {
		modelUsers = append(modelUsers, mapUserToModel(u))
	}
	return modelUsers, nil
}

// CheckUsername is the resolver for the checkUsername field.
func (r *queryResolver) CheckUsername(ctx context.Context, username string) (bool, error) {
	user, err := r.UserRepo.GetByUsername(ctx, username)
	if err != nil {

		return true, nil
	}

	return user == nil, nil
}

// Me is the resolver for the me field.
func (r *queryResolver) Me(ctx context.Context) (*model.User, error) {
	user := auth.ForContext(ctx)
	if user == nil {
		return nil, fmt.Errorf("not authenticated")
	}
	return mapUserToModel(user), nil
}

// User is the resolver for the user field.
func (r *queryResolver) User(ctx context.Context, username string) (*model.PublicUser, error) {
	user, err := r.UserRepo.GetByUsername(ctx, username)
	if err != nil {
		return nil, err
	}
	if user == nil {
		return nil, fmt.Errorf("user not found")
	}
	return mapPublicUserToModel(mapUserToPublic(user)), nil
}

// PublicUser returns PublicUserResolver implementation.
func (r *Resolver) PublicUser() PublicUserResolver { return &publicUserResolver{r} }

type publicUserResolver struct{ *Resolver }
