package graph

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.86

import (
	"context"
	"fmt"
	"time"

	"github.com/pranava-mohan/wikinitt/gravy/graph/model"
	"github.com/pranava-mohan/wikinitt/gravy/internal/auth"
	"github.com/pranava-mohan/wikinitt/gravy/internal/community"
	"github.com/pranava-mohan/wikinitt/gravy/internal/sanitization"
	"github.com/pranava-mohan/wikinitt/gravy/internal/users"
)

// Replies is the resolver for the replies field.
func (r *commentResolver) Replies(ctx context.Context, obj *model.Comment, limit *int32, offset *int32) ([]*model.Comment, error) {
	l := 10
	o := 0
	if limit != nil {
		l = int(*limit)
	}
	if offset != nil {
		o = int(*offset)
	}

	replies, err := r.CommunityRepo.ListReplies(ctx, obj.ID, l, o)
	if err != nil {
		return nil, err
	}

	var modelReplies []*model.Comment
	for _, reply := range replies {

		author, _ := r.UserRepo.GetByID(ctx, reply.AuthorID)
		authorPublic := &users.PublicUser{
			ID:          author.ID,
			Name:        author.Name,
			Username:    author.Username,
			DisplayName: author.DisplayName,
			Gender:      author.Gender,
			Avatar:      author.Avatar,
		}

		post, _ := r.CommunityRepo.GetPost(ctx, reply.PostID)
		postAuthor, _ := r.UserRepo.GetByID(ctx, post.AuthorID)
		postAuthorPublic := &users.PublicUser{
			ID:          postAuthor.ID,
			Name:        postAuthor.Name,
			Username:    postAuthor.Username,
			DisplayName: postAuthor.DisplayName,
			Gender:      postAuthor.Gender,
			Avatar:      postAuthor.Avatar,
		}

		group, _ := r.CommunityRepo.GetGroupByID(ctx, post.GroupID)
		groupOwner, _ := r.UserRepo.GetByID(ctx, group.OwnerID)
		groupOwnerPublic := &users.PublicUser{
			ID:          groupOwner.ID,
			Name:        groupOwner.Name,
			Username:    groupOwner.Username,
			DisplayName: groupOwner.DisplayName,
			Gender:      groupOwner.Gender,
			Avatar:      groupOwner.Avatar,
		}

		replyModel := mapCommentToModel(reply, authorPublic, post, postAuthorPublic, group, groupOwnerPublic)

		user := auth.ForContext(ctx)
		if user != nil {
			voteType, _ := r.CommunityRepo.GetUserCommentVote(ctx, user.ID, reply.ID)
			switch voteType {
			case "UP":
				replyModel.UserVote = model.VoteTypeUp
			case "DOWN":
				replyModel.UserVote = model.VoteTypeDown
			default:
				replyModel.UserVote = model.VoteTypeNone
			}
		}

		modelReplies = append(modelReplies, replyModel)
	}

	return modelReplies, nil
}

// UserVote is the resolver for the userVote field.
func (r *commentResolver) UserVote(ctx context.Context, obj *model.Comment) (model.VoteType, error) {
	user := auth.ForContext(ctx)
	if user == nil {
		return model.VoteTypeNone, nil
	}
	voteType, err := r.CommunityRepo.GetUserCommentVote(ctx, user.ID, obj.ID)
	if err != nil {
		return model.VoteTypeNone, nil
	}
	switch voteType {
	case "UP":
		return model.VoteTypeUp, nil
	case "DOWN":
		return model.VoteTypeDown, nil
	default:
		return model.VoteTypeNone, nil
	}
}

// IsMember is the resolver for the isMember field.
func (r *groupResolver) IsMember(ctx context.Context, obj *model.Group) (bool, error) {
	user := auth.ForContext(ctx)
	if user == nil {
		return false, nil
	}
	return r.CommunityRepo.IsMember(ctx, obj.ID, user.ID)
}

// Posts is the resolver for the posts field.
func (r *groupResolver) Posts(ctx context.Context, obj *model.Group, limit *int32, offset *int32) ([]*model.Post, error) {
	l := 10
	o := 0
	if limit != nil {
		l = int(*limit)
	}
	if offset != nil {
		o = int(*offset)
	}

	if obj.Type == model.GroupTypePrivate {
		user := auth.ForContext(ctx)
		if user == nil {
			return nil, fmt.Errorf("access denied: private group")
		}
		isMember, err := r.CommunityRepo.IsMember(ctx, obj.ID, user.ID)
		if err != nil {
			return nil, err
		}
		if !isMember {
			return nil, fmt.Errorf("access denied: must be a member to view posts")
		}
	}

	posts, err := r.CommunityRepo.ListPosts(ctx, obj.ID, l, o)
	if err != nil {
		return nil, err
	}

	var modelPosts []*model.Post
	for _, p := range posts {
		author, _ := r.UserRepo.GetByID(ctx, p.AuthorID)
		authorPublic := &users.PublicUser{
			ID:          author.ID,
			Name:        author.Name,
			Username:    author.Username,
			DisplayName: author.DisplayName,
			Gender:      author.Gender,
			Avatar:      author.Avatar,
		}

		group, _ := r.CommunityRepo.GetGroupByID(ctx, p.GroupID)
		groupOwner, _ := r.UserRepo.GetByID(ctx, group.OwnerID)
		groupOwnerPublic := &users.PublicUser{
			ID:          groupOwner.ID,
			Name:        groupOwner.Name,
			Username:    groupOwner.Username,
			DisplayName: groupOwner.DisplayName,
			Gender:      groupOwner.Gender,
			Avatar:      groupOwner.Avatar,
		}

		modelPosts = append(modelPosts, mapPostToModel(p, authorPublic, group, groupOwnerPublic))
	}
	return modelPosts, nil
}

// CreateGroup is the resolver for the createGroup field.
func (r *mutationResolver) CreateGroup(ctx context.Context, input model.NewGroup) (*model.Group, error) {
	user := auth.ForContext(ctx)
	if user == nil {
		return nil, fmt.Errorf("not authenticated")
	}

	baseSlug := generateSlug(input.Name)
	slug := baseSlug

	for {
		_, err := r.CommunityRepo.GetGroup(ctx, slug)
		if err != nil {

			break
		}

		slug = fmt.Sprintf("%s-%s", baseSlug, randString(6))
	}

	group := &community.Group{
		Name:         input.Name,
		Description:  input.Description,
		Slug:         slug,
		Type:         community.GroupType(input.Type),
		OwnerID:      user.ID,
		MembersCount: 1,
		MemberIDs:    []string{user.ID},
		CreatedAt:    time.Now(),
	}

	err := r.CommunityRepo.CreateGroup(ctx, group)
	if err != nil {
		return nil, err
	}

	owner := &users.PublicUser{
		ID:          user.ID,
		Name:        user.Name,
		Username:    user.Username,
		DisplayName: user.DisplayName,
		Gender:      user.Gender,
		Avatar:      user.Avatar,
	}

	return mapGroupToModel(group, owner), nil
}

// JoinGroup is the resolver for the joinGroup field.
func (r *mutationResolver) JoinGroup(ctx context.Context, groupID string) (bool, error) {
	user := auth.ForContext(ctx)
	if user == nil {
		return false, fmt.Errorf("not authenticated")
	}

	err := r.CommunityRepo.JoinGroup(ctx, groupID, user.ID)
	if err != nil {
		return false, err
	}
	return true, nil
}

// LeaveGroup is the resolver for the leaveGroup field.
func (r *mutationResolver) LeaveGroup(ctx context.Context, groupID string) (bool, error) {
	user := auth.ForContext(ctx)
	if user == nil {
		return false, fmt.Errorf("not authenticated")
	}

	err := r.CommunityRepo.LeaveGroup(ctx, groupID, user.ID)
	if err != nil {
		return false, err
	}
	return true, nil
}

// CreatePost is the resolver for the createPost field.
func (r *mutationResolver) CreatePost(ctx context.Context, input model.NewPost) (*model.Post, error) {
	user := auth.ForContext(ctx)
	if user == nil {
		return nil, fmt.Errorf("not authenticated")
	}

	isMember, err := r.CommunityRepo.IsMember(ctx, input.GroupID, user.ID)
	if err != nil {
		return nil, err
	}
	if !isMember {
		return nil, fmt.Errorf("must be a member of the group to create a post")
	}

	post := &community.Post{
		Title:     sanitization.SanitizeString(input.Title),
		Content:   sanitization.SanitizeContent(input.Content),
		AuthorID:  user.ID,
		GroupID:   input.GroupID,
		CreatedAt: time.Now(),
	}

	err = r.CommunityRepo.CreatePost(ctx, post)
	if err != nil {
		return nil, err
	}

	group, err := r.CommunityRepo.GetGroupByID(ctx, input.GroupID)
	if err != nil {
		return nil, err
	}
	groupOwner, _ := r.UserRepo.GetByID(ctx, group.OwnerID)
	groupOwnerPublic := &users.PublicUser{
		ID:          groupOwner.ID,
		Name:        groupOwner.Name,
		Username:    groupOwner.Username,
		DisplayName: groupOwner.DisplayName,
		Gender:      groupOwner.Gender,
		Avatar:      groupOwner.Avatar,
	}

	author := &users.PublicUser{
		ID:          user.ID,
		Name:        user.Name,
		Username:    user.Username,
		DisplayName: user.DisplayName,
		Gender:      user.Gender,
		Avatar:      user.Avatar,
	}

	return mapPostToModel(post, author, group, groupOwnerPublic), nil
}

// CreateComment is the resolver for the createComment field.
func (r *mutationResolver) CreateComment(ctx context.Context, input model.NewComment) (*model.Comment, error) {
	user := auth.ForContext(ctx)
	if user == nil {
		return nil, fmt.Errorf("not authenticated")
	}

	comment := &community.Comment{
		Content:   sanitization.SanitizeContent(input.Content),
		AuthorID:  user.ID,
		PostID:    input.PostID,
		ParentID:  input.ParentID,
		CreatedAt: time.Now(),
	}

	err := r.CommunityRepo.CreateComment(ctx, comment)
	if err != nil {
		return nil, err
	}

	post, _ := r.CommunityRepo.GetPost(ctx, input.PostID)
	postAuthor, _ := r.UserRepo.GetByID(ctx, post.AuthorID)
	postAuthorPublic := &users.PublicUser{
		ID:          postAuthor.ID,
		Name:        postAuthor.Name,
		Username:    postAuthor.Username,
		DisplayName: postAuthor.DisplayName,
		Gender:      postAuthor.Gender,
		Avatar:      postAuthor.Avatar,
	}
	group, _ := r.CommunityRepo.GetGroupByID(ctx, post.GroupID)
	groupOwner, _ := r.UserRepo.GetByID(ctx, group.OwnerID)
	groupOwnerPublic := &users.PublicUser{
		ID:          groupOwner.ID,
		Name:        groupOwner.Name,
		Username:    groupOwner.Username,
		DisplayName: groupOwner.DisplayName,
		Gender:      groupOwner.Gender,
		Avatar:      groupOwner.Avatar,
	}

	author := &users.PublicUser{
		ID:          user.ID,
		Name:        user.Name,
		Username:    user.Username,
		DisplayName: user.DisplayName,
		Gender:      user.Gender,
		Avatar:      user.Avatar,
	}

	return mapCommentToModel(comment, author, post, postAuthorPublic, group, groupOwnerPublic), nil
}

// VotePost is the resolver for the votePost field.
func (r *mutationResolver) VotePost(ctx context.Context, postID string, typeArg model.VoteType) (*model.Post, error) {
	user := auth.ForContext(ctx)
	if user == nil {
		return nil, fmt.Errorf("not authenticated")
	}

	err := r.CommunityRepo.VotePost(ctx, user.ID, postID, typeArg.String())
	if err != nil {
		return nil, err
	}

	return r.Query().Post(ctx, postID)
}

// VoteComment is the resolver for the voteComment field.
func (r *mutationResolver) VoteComment(ctx context.Context, commentID string, typeArg model.VoteType) (*model.Comment, error) {
	user := auth.ForContext(ctx)
	if user == nil {
		return nil, fmt.Errorf("not authenticated")
	}

	err := r.CommunityRepo.VoteComment(ctx, user.ID, commentID, typeArg.String())
	if err != nil {
		return nil, err
	}

	c, err := r.CommunityRepo.GetComment(ctx, commentID)
	if err != nil {
		return nil, err
	}

	author, _ := r.UserRepo.GetByID(ctx, c.AuthorID)
	authorPublic := &users.PublicUser{
		ID:          author.ID,
		Name:        author.Name,
		Username:    author.Username,
		DisplayName: author.DisplayName,
		Gender:      author.Gender,
		Avatar:      author.Avatar,
	}

	post, _ := r.CommunityRepo.GetPost(ctx, c.PostID)
	postAuthor, _ := r.UserRepo.GetByID(ctx, post.AuthorID)
	postAuthorPublic := &users.PublicUser{
		ID:          postAuthor.ID,
		Name:        postAuthor.Name,
		Username:    postAuthor.Username,
		DisplayName: postAuthor.DisplayName,
		Gender:      postAuthor.Gender,
		Avatar:      postAuthor.Avatar,
	}

	group, _ := r.CommunityRepo.GetGroupByID(ctx, post.GroupID)
	groupOwner, _ := r.UserRepo.GetByID(ctx, group.OwnerID)
	groupOwnerPublic := &users.PublicUser{
		ID:          groupOwner.ID,
		Name:        groupOwner.Name,
		Username:    groupOwner.Username,
		DisplayName: groupOwner.DisplayName,
		Gender:      groupOwner.Gender,
		Avatar:      groupOwner.Avatar,
	}

	result := mapCommentToModel(c, authorPublic, post, postAuthorPublic, group, groupOwnerPublic)

	voteType, _ := r.CommunityRepo.GetUserCommentVote(ctx, user.ID, commentID)
	switch voteType {
	case "UP":
		result.UserVote = model.VoteTypeUp
	case "DOWN":
		result.UserVote = model.VoteTypeDown
	default:
		result.UserVote = model.VoteTypeNone
	}

	return result, nil
}

// UpdateGroup is the resolver for the updateGroup field.
func (r *mutationResolver) UpdateGroup(ctx context.Context, groupID string, name *string, description *string, icon *string) (*model.Group, error) {
	user := auth.ForContext(ctx)
	if user == nil {
		return nil, fmt.Errorf("not authenticated")
	}

	group, err := r.CommunityRepo.GetGroupByID(ctx, groupID)
	if err != nil {
		return nil, err
	}

	if group.OwnerID != user.ID {
		return nil, fmt.Errorf("access denied: only group owner can edit")
	}

	updatedGroup, err := r.CommunityRepo.UpdateGroup(ctx, groupID, name, description, icon)
	if err != nil {
		return nil, err
	}

	owner, _ := r.UserRepo.GetByID(ctx, updatedGroup.OwnerID)
	return mapGroupToModel(updatedGroup, mapUserToPublic(owner)), nil
}

// UserVote is the resolver for the userVote field.
func (r *postResolver) UserVote(ctx context.Context, obj *model.Post) (model.VoteType, error) {
	user := auth.ForContext(ctx)
	if user == nil {
		return model.VoteTypeNone, nil
	}
	voteType, err := r.CommunityRepo.GetUserVote(ctx, user.ID, obj.ID)
	if err != nil {
		return model.VoteTypeNone, nil
	}
	switch voteType {
	case "UP":
		return model.VoteTypeUp, nil
	case "DOWN":
		return model.VoteTypeDown, nil
	default:
		return model.VoteTypeNone, nil
	}
}

// Comments is the resolver for the comments field.
func (r *postResolver) Comments(ctx context.Context, obj *model.Post, limit *int32, offset *int32) ([]*model.Comment, error) {
	l := 10
	o := 0
	if limit != nil {
		l = int(*limit)
	}
	if offset != nil {
		o = int(*offset)
	}

	fmt.Printf("Fetching comments for post %s (limit: %d, offset: %d)\n", obj.ID, l, o)

	comments, err := r.CommunityRepo.ListComments(ctx, obj.ID, nil, l, o)
	if err != nil {
		fmt.Printf("Error fetching comments: %v\n", err)
		return nil, err
	}
	fmt.Printf("Found %d comments for post %s\n", len(comments), obj.ID)

	var modelComments []*model.Comment
	for _, c := range comments {
		author, err := r.UserRepo.GetByID(ctx, c.AuthorID)
		var authorPublic *users.PublicUser
		if err != nil {
			fmt.Printf("Error fetching author %s for comment %s: %v\n", c.AuthorID, c.ID, err)

			authorPublic = &users.PublicUser{
				ID:          "unknown",
				Name:        "Unknown User",
				Username:    "unknown",
				DisplayName: "Unknown User",
				Gender:      "unknown",
				Avatar:      "",
			}
		} else {
			authorPublic = &users.PublicUser{
				ID:          author.ID,
				Name:        author.Name,
				Username:    author.Username,
				DisplayName: author.DisplayName,
				Gender:      author.Gender,
				Avatar:      author.Avatar,
			}
		}

		post, err := r.CommunityRepo.GetPost(ctx, c.PostID)
		if err != nil {
			fmt.Printf("Error fetching post %s for comment %s: %v\n", c.PostID, c.ID, err)

			post = &community.Post{
				ID:      c.PostID,
				Title:   "Unknown Post",
				Content: "Unknown Content",
				GroupID: "unknown",
			}
		}

		postAuthor, err := r.UserRepo.GetByID(ctx, post.AuthorID)
		var postAuthorPublic *users.PublicUser
		if err != nil {

			postAuthorPublic = &users.PublicUser{
				ID:       "unknown",
				Name:     "Unknown",
				Username: "unknown",
			}
		} else {
			postAuthorPublic = &users.PublicUser{
				ID:          postAuthor.ID,
				Name:        postAuthor.Name,
				Username:    postAuthor.Username,
				DisplayName: postAuthor.DisplayName,
				Gender:      postAuthor.Gender,
				Avatar:      postAuthor.Avatar,
			}
		}

		group, err := r.CommunityRepo.GetGroupByID(ctx, post.GroupID)
		if err != nil {
			fmt.Printf("Error fetching group %s for post %s: %v\n", post.GroupID, post.ID, err)
			group = &community.Group{
				ID:   post.GroupID,
				Name: "Unknown Group",
				Slug: "unknown",
				Type: community.GroupTypePublic,
			}
		}

		groupOwner, err := r.UserRepo.GetByID(ctx, group.OwnerID)
		var groupOwnerPublic *users.PublicUser
		if err != nil {
			groupOwnerPublic = &users.PublicUser{
				ID:       "unknown",
				Name:     "Unknown",
				Username: "unknown",
			}
		} else {
			groupOwnerPublic = &users.PublicUser{
				ID:          groupOwner.ID,
				Name:        groupOwner.Name,
				Username:    groupOwner.Username,
				DisplayName: groupOwner.DisplayName,
				Gender:      groupOwner.Gender,
				Avatar:      groupOwner.Avatar,
			}
		}

		modelComments = append(modelComments, mapCommentToModel(c, authorPublic, post, postAuthorPublic, group, groupOwnerPublic))
	}
	return modelComments, nil
}

// Groups is the resolver for the groups field.
func (r *queryResolver) Groups(ctx context.Context, limit *int32, offset *int32, ownerID *string, typeArg *model.GroupType) ([]*model.Group, error) {
	l := 10
	o := 0
	if limit != nil {
		l = int(*limit)
	}
	if offset != nil {
		o = int(*offset)
	}

	filter := community.GroupFilter{}
	if ownerID != nil {
		filter.OwnerID = ownerID
	}
	if typeArg != nil {
		t := community.GroupType(*typeArg)
		filter.Type = &t
	}

	groups, err := r.CommunityRepo.ListGroups(ctx, filter, l, o)
	if err != nil {
		return nil, err
	}

	var modelGroups []*model.Group
	for _, g := range groups {
		owner, _ := r.UserRepo.GetByID(ctx, g.OwnerID)
		ownerPublic := &users.PublicUser{
			ID:          owner.ID,
			Name:        owner.Name,
			Username:    owner.Username,
			DisplayName: owner.DisplayName,
			Gender:      owner.Gender,
			Avatar:      owner.Avatar,
		}
		modelGroups = append(modelGroups, mapGroupToModel(g, ownerPublic))
	}
	return modelGroups, nil
}

// Group is the resolver for the group field.
func (r *queryResolver) Group(ctx context.Context, slug string) (*model.Group, error) {
	g, err := r.CommunityRepo.GetGroup(ctx, slug)
	if err != nil {
		return nil, err
	}
	owner, _ := r.UserRepo.GetByID(ctx, g.OwnerID)
	ownerPublic := &users.PublicUser{
		ID:          owner.ID,
		Name:        owner.Name,
		Username:    owner.Username,
		DisplayName: owner.DisplayName,
		Gender:      owner.Gender,
		Avatar:      owner.Avatar,
	}
	return mapGroupToModel(g, ownerPublic), nil
}

// Post is the resolver for the post field.
func (r *queryResolver) Post(ctx context.Context, id string) (*model.Post, error) {
	fmt.Printf("Fetching post %s\n", id)
	p, err := r.CommunityRepo.GetPost(ctx, id)
	if err != nil {
		fmt.Printf("Error fetching post %s: %v\n", id, err)
		return nil, err
	}
	author, _ := r.UserRepo.GetByID(ctx, p.AuthorID)
	authorPublic := &users.PublicUser{
		ID:          author.ID,
		Name:        author.Name,
		Username:    author.Username,
		DisplayName: author.DisplayName,
		Gender:      author.Gender,
		Avatar:      author.Avatar,
	}
	group, _ := r.CommunityRepo.GetGroupByID(ctx, p.GroupID)

	if group.Type == community.GroupTypePrivate {
		user := auth.ForContext(ctx)
		if user == nil {
			return nil, fmt.Errorf("access denied: private group")
		}
		isMember, err := r.CommunityRepo.IsMember(ctx, group.ID, user.ID)
		if err != nil {
			return nil, err
		}
		if !isMember {
			return nil, fmt.Errorf("access denied: must be a member to view post")
		}
	}

	groupOwner, _ := r.UserRepo.GetByID(ctx, group.OwnerID)
	groupOwnerPublic := &users.PublicUser{
		ID:          groupOwner.ID,
		Name:        groupOwner.Name,
		Username:    groupOwner.Username,
		DisplayName: groupOwner.DisplayName,
		Gender:      groupOwner.Gender,
		Avatar:      groupOwner.Avatar,
	}
	return mapPostToModel(p, authorPublic, group, groupOwnerPublic), nil
}

// Comment is the resolver for the comment field.
func (r *queryResolver) Comment(ctx context.Context, id string) (*model.Comment, error) {
	c, err := r.CommunityRepo.GetComment(ctx, id)
	if err != nil {
		return nil, err
	}

	author, _ := r.UserRepo.GetByID(ctx, c.AuthorID)
	authorPublic := &users.PublicUser{
		ID:          author.ID,
		Name:        author.Name,
		Username:    author.Username,
		DisplayName: author.DisplayName,
		Gender:      author.Gender,
		Avatar:      author.Avatar,
	}

	post, _ := r.CommunityRepo.GetPost(ctx, c.PostID)
	postAuthor, _ := r.UserRepo.GetByID(ctx, post.AuthorID)
	postAuthorPublic := &users.PublicUser{
		ID:          postAuthor.ID,
		Name:        postAuthor.Name,
		Username:    postAuthor.Username,
		DisplayName: postAuthor.DisplayName,
		Gender:      postAuthor.Gender,
		Avatar:      postAuthor.Avatar,
	}

	group, _ := r.CommunityRepo.GetGroupByID(ctx, post.GroupID)
	groupOwner, _ := r.UserRepo.GetByID(ctx, group.OwnerID)
	groupOwnerPublic := &users.PublicUser{
		ID:          groupOwner.ID,
		Name:        groupOwner.Name,
		Username:    groupOwner.Username,
		DisplayName: groupOwner.DisplayName,
		Gender:      groupOwner.Gender,
		Avatar:      groupOwner.Avatar,
	}

	result := mapCommentToModel(c, authorPublic, post, postAuthorPublic, group, groupOwnerPublic)

	user := auth.ForContext(ctx)
	if user != nil {
		voteType, _ := r.CommunityRepo.GetUserCommentVote(ctx, user.ID, c.ID)
		switch voteType {
		case "UP":
			result.UserVote = model.VoteTypeUp
		case "DOWN":
			result.UserVote = model.VoteTypeDown
		default:
			result.UserVote = model.VoteTypeNone
		}
	}

	return result, nil
}

// PublicPosts is the resolver for the publicPosts field.
func (r *queryResolver) PublicPosts(ctx context.Context, limit *int32, offset *int32) ([]*model.Post, error) {
	l := 10
	o := 0
	if limit != nil {
		l = int(*limit)
	}
	if offset != nil {
		o = int(*offset)
	}

	posts, err := r.CommunityRepo.ListPublicPosts(ctx, l, o)
	if err != nil {
		return nil, err
	}

	var modelPosts []*model.Post
	for _, p := range posts {
		author, _ := r.UserRepo.GetByID(ctx, p.AuthorID)
		authorPublic := &users.PublicUser{
			ID:          author.ID,
			Name:        author.Name,
			Username:    author.Username,
			DisplayName: author.DisplayName,
			Gender:      author.Gender,
			Avatar:      author.Avatar,
		}

		group, _ := r.CommunityRepo.GetGroupByID(ctx, p.GroupID)
		groupOwner, _ := r.UserRepo.GetByID(ctx, group.OwnerID)
		groupOwnerPublic := &users.PublicUser{
			ID:          groupOwner.ID,
			Name:        groupOwner.Name,
			Username:    groupOwner.Username,
			DisplayName: groupOwner.DisplayName,
			Gender:      groupOwner.Gender,
			Avatar:      groupOwner.Avatar,
		}

		modelPosts = append(modelPosts, mapPostToModel(p, authorPublic, group, groupOwnerPublic))
	}
	return modelPosts, nil
}

// Comment returns CommentResolver implementation.
func (r *Resolver) Comment() CommentResolver { return &commentResolver{r} }

// Group returns GroupResolver implementation.
func (r *Resolver) Group() GroupResolver { return &groupResolver{r} }

// Post returns PostResolver implementation.
func (r *Resolver) Post() PostResolver { return &postResolver{r} }

type commentResolver struct{ *Resolver }
type groupResolver struct{ *Resolver }
type postResolver struct{ *Resolver }
