package graph

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.86

import (
	"context"
	"fmt"

	"github.com/99designs/gqlgen/graphql"
	"github.com/pranava-mohan/wikinitt/gravy/graph/model"
	"github.com/pranava-mohan/wikinitt/gravy/internal/articles"
	"github.com/pranava-mohan/wikinitt/gravy/internal/auth"
	"github.com/pranava-mohan/wikinitt/gravy/internal/sanitization"
	"github.com/pranava-mohan/wikinitt/gravy/internal/users"
)

// CreateArticle is the resolver for the createArticle field.
func (r *mutationResolver) CreateArticle(ctx context.Context, input model.NewArticle) (*model.Article, error) {
	slug, err := articles.GenerateSlug(input.Title, 50)
	if err != nil {
		return nil, err
	}

	sanitizedContent := sanitization.SanitizeContent(input.Content)

	autoLinkedContent, err := articles.AutoLinkContent(ctx, sanitizedContent, r.ArticleRepo, "")
	if err != nil {
		return nil, err
	} 

	article := articles.Article{
		Title:     input.Title,
		Content:   autoLinkedContent,
		Slug:      slug,
		Category:  input.Category,
		Thumbnail: sanitization.SanitizeString(input.Thumbnail),
		Featured:  input.Featured,
	}

	user := auth.ForContext(ctx)
	if user == nil {
		return nil, fmt.Errorf("unauthorized")
	}
	article.AuthorID = user.ID

	created, err := r.ArticleRepo.Create(ctx, article)
	if err != nil {
		return nil, err
	}

	created.Author = &users.PublicUser{
		ID:     user.ID,
		Name:   user.Name,
		Gender: user.Gender,
		Avatar: user.Avatar,
	}

	return mapArticleToModel(created), nil
}

// UpdateArticle is the resolver for the updateArticle field.
func (r *mutationResolver) UpdateArticle(ctx context.Context, input model.UpdateArticle) (*model.Article, error) {
	
	existing, err := r.ArticleRepo.GetByID(ctx, input.ID)
	if err != nil {
		return nil, err
	}
	
	updates := make(map[string]interface{})
	if input.Title != nil {
		updates["title"] = *input.Title
	}
	if input.Content != nil {
		sanitizedContent := sanitization.SanitizeContent(*input.Content)

		autoLinkedContent, err := articles.AutoLinkContent(ctx, sanitizedContent, r.ArticleRepo, existing.Slug)
		if err != nil {
			return nil, err
		}

		updates["content"] = autoLinkedContent
	}
	if input.Category != nil {
		updates["category"] = *input.Category
	}
	if input.Thumbnail != nil {
		updates["thumbnail"] = sanitization.SanitizeString(*input.Thumbnail)
	}
	if input.Featured != nil {
		updates["featured"] = *input.Featured
	}

	updated, err := r.ArticleRepo.Update(ctx, input.ID, updates)
	if err != nil {
		return nil, err
	}

	author, err := r.UserRepo.GetByID(ctx, updated.AuthorID)
	if err == nil {
		updated.Author = &users.PublicUser{
			ID:     author.ID,
			Name:   author.Name,
			Gender: author.Gender,
			Avatar: author.Avatar,
		}
	}

	return mapArticleToModel(updated), nil
}

// DeleteArticle is the resolver for the deleteArticle field.
func (r *mutationResolver) DeleteArticle(ctx context.Context, id string) (bool, error) {
	err := r.ArticleRepo.Delete(ctx, id)
	if err != nil {
		return false, err
	}
	return true, nil
}

// UploadImage is the resolver for the uploadImage field.
func (r *mutationResolver) UploadImage(ctx context.Context, file graphql.Upload) (string, error) {
	url, err := r.Uploader.UploadImage(ctx, file.File, "wikinitt/articles")
	if err != nil {
		return "", err
	}
	return url, nil
}

// Articles is the resolver for the articles field.
func (r *queryResolver) Articles(ctx context.Context, category *string, limit *int32, offset *int32, featured *bool) ([]*model.Article, error) {
	var l, o *int
	if limit != nil {
		val := int(*limit)
		l = &val

		if *l > 25 || *l < 1 {
			*l = 10
		}
	}
	if offset != nil {
		val := int(*offset)
		o = &val
	}

	articles, err := r.ArticleRepo.List(ctx, category, l, o, featured)
	if err != nil {
		return nil, err
	}
	var modelArticles []*model.Article
	for _, a := range articles {
		author, err := r.UserRepo.GetByID(ctx, a.AuthorID)
		if err == nil {
			a.Author = &users.PublicUser{
				ID:     author.ID,
				Name:   author.Name,
				Gender: author.Gender,
				Avatar: author.Avatar,
			}
		}
		modelArticles = append(modelArticles, mapArticleToModel(a))
	}
	return modelArticles, nil
}

// Article is the resolver for the article field.
func (r *queryResolver) Article(ctx context.Context, id string) (*model.Article, error) {
	article, err := r.ArticleRepo.GetByID(ctx, id)
	if err != nil {
		return nil, err
	}

	author, err := r.UserRepo.GetByID(ctx, article.AuthorID)
	if err == nil {
		article.Author = &users.PublicUser{
			ID:     author.ID,
			Name:   author.Name,
			Gender: author.Gender,
			Avatar: author.Avatar,
		}
	}
	return mapArticleToModel(article), nil
}

// ArticleBySlug is the resolver for the articleBySlug field.
func (r *queryResolver) ArticleBySlug(ctx context.Context, slug string) (*model.Article, error) {
	article, err := r.ArticleRepo.GetBySlug(ctx, slug)
	if err != nil {
		return nil, err
	}

	author, err := r.UserRepo.GetByID(ctx, article.AuthorID)
	if err == nil {
		article.Author = &users.PublicUser{
			ID:     author.ID,
			Name:   author.Name,
			Gender: author.Gender,
			Avatar: author.Avatar,
		}
	}
	return mapArticleToModel(article), nil
}
