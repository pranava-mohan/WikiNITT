package graph

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.86

import (
	"context"
	"fmt"

	"github.com/pranava-mohan/wikinitt/gravy/graph/model"
	"github.com/pranava-mohan/wikinitt/gravy/internal/community"
	"github.com/pranava-mohan/wikinitt/gravy/internal/users"
	"golang.org/x/sync/errgroup"
)

// SearchArticles is the resolver for the searchArticles field.
func (r *queryResolver) SearchArticles(ctx context.Context, query string, limit *int32, offset *int32) ([]*model.Article, error) {
	l := 10
	if limit != nil {
		l = int(*limit)
	}
	o := 0
	if offset != nil {
		o = int(*offset)
	}

	ids, err := r.SearchClient.SearchArticles(ctx, query, l, o)
	if err != nil {
		return nil, fmt.Errorf("search failed: %w", err)
	}

	articles, err := r.ArticleRepo.GetByIDs(ctx, ids)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch articles: %w", err)
	}

	var result []*model.Article
	for _, a := range articles {
		author, err := r.UserRepo.GetByID(ctx, a.AuthorID)
		if err == nil {
			a.Author = &users.PublicUser{
				ID:     author.ID,
				Name:   author.Name,
				Gender: author.Gender,
				Avatar: author.Avatar,
			}
		}
		result = append(result, mapArticleToModel(a))
	}
	return result, nil
}

// SearchPosts is the resolver for the searchPosts field.
func (r *queryResolver) SearchPosts(ctx context.Context, query string, limit *int32, offset *int32) ([]*model.Post, error) {
	l := 10
	if limit != nil {
		l = int(*limit)
	}
	o := 0
	if offset != nil {
		o = int(*offset)
	}

	ids, err := r.SearchClient.SearchPosts(ctx, query, l, o)
	if err != nil {
		return nil, fmt.Errorf("search failed: %w", err)
	}

	posts, err := r.CommunityRepo.GetPostsByIDs(ctx, ids)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch posts: %w", err)
	}

	var result []*model.Post
	for _, p := range posts {
		author, _ := r.UserRepo.GetByID(ctx, p.AuthorID)
		authorPublic := &users.PublicUser{
			ID:          author.ID,
			Name:        author.Name,
			Username:    author.Username,
			DisplayName: author.DisplayName,
			Gender:      author.Gender,
			Avatar:      author.Avatar,
		}

		group, _ := r.CommunityRepo.GetGroupByID(ctx, p.GroupID)
		groupOwner, _ := r.UserRepo.GetByID(ctx, group.OwnerID)
		groupOwnerPublic := &users.PublicUser{
			ID:          groupOwner.ID,
			Name:        groupOwner.Name,
			Username:    groupOwner.Username,
			DisplayName: groupOwner.DisplayName,
			Gender:      groupOwner.Gender,
			Avatar:      groupOwner.Avatar,
		}

		result = append(result, mapPostToModel(p, authorPublic, group, groupOwnerPublic))
	}
	return result, nil
}

// SearchCommunity is the resolver for the searchCommunity field.
func (r *queryResolver) SearchCommunity(ctx context.Context, query string, limit *int32, offset *int32) ([]model.CommunityResult, error) {
	l := 10
	if limit != nil {
		l = int(*limit)
	}
	o := 0
	if offset != nil {
		o = int(*offset)
	}

	hits, err := r.SearchClient.SearchCommunity(ctx, query, l, o)
	if err != nil {
		return nil, fmt.Errorf("search failed: %w", err)
	}

	var postIDs, groupIDs, commentIDs []string
	typeMap := make(map[string]string)

	for _, hit := range hits {
		typeMap[hit.ID] = hit.Type
		switch hit.Type {
		case "post":
			postIDs = append(postIDs, hit.ID)
		case "group":
			groupIDs = append(groupIDs, hit.ID)
		case "comment":
			commentIDs = append(commentIDs, hit.ID)
		}
	}

	// Fetch data in parallel
	var (
		posts    []*community.Post
		groups   []*community.Group
		comments []*community.Comment
	)

	g, gCtx := errgroup.WithContext(ctx)

	g.Go(func() error {
		var err error
		posts, err = r.CommunityRepo.GetPostsByIDs(gCtx, postIDs)
		if err != nil {
			return fmt.Errorf("failed to fetch posts: %w", err)
		}
		return nil
	})

	g.Go(func() error {
		var err error
		groups, err = r.CommunityRepo.GetGroupsByIDs(gCtx, groupIDs)
		if err != nil {
			return fmt.Errorf("failed to fetch groups: %w", err)
		}
		return nil
	})

	g.Go(func() error {
		var err error
		comments, err = r.CommunityRepo.GetCommentsByIDs(gCtx, commentIDs)
		if err != nil {
			return fmt.Errorf("failed to fetch comments: %w", err)
		}
		return nil
	})

	if err := g.Wait(); err != nil {
		return nil, err
	}

	// Map results by ID for easy lookup
	resultMap := make(map[string]model.CommunityResult)

	for _, p := range posts {
		author, _ := r.UserRepo.GetByID(ctx, p.AuthorID)
		authorPublic := mapUserToPublic(author)
		if authorPublic == nil {
			// Fallback if author deleted/missing
			authorPublic = &users.PublicUser{ID: "unknown", Name: "Unknown"}
		}

		group, _ := r.CommunityRepo.GetGroupByID(ctx, p.GroupID)
		var groupOwnerPublic *users.PublicUser
		if group != nil {
			groupOwner, _ := r.UserRepo.GetByID(ctx, group.OwnerID)
			groupOwnerPublic = mapUserToPublic(groupOwner)
		} else {
			// Fallback
			group = &community.Group{ID: "unknown", Name: "Unknown Group"}
		}

		resultMap[p.ID] = mapPostToModel(p, authorPublic, group, groupOwnerPublic)
	}

	for _, g := range groups {
		owner, _ := r.UserRepo.GetByID(ctx, g.OwnerID)
		ownerPublic := mapUserToPublic(owner)
		resultMap[g.ID] = mapGroupToModel(g, ownerPublic)
	}

	for _, c := range comments {
		author, _ := r.UserRepo.GetByID(ctx, c.AuthorID)
		authorPublic := mapUserToPublic(author)
		if authorPublic == nil {
			authorPublic = &users.PublicUser{ID: "unknown", Name: "Unknown"}
		}

		post, _ := r.CommunityRepo.GetPost(ctx, c.PostID)
		var postAuthorPublic *users.PublicUser
		var group *community.Group
		var groupOwnerPublic *users.PublicUser

		if post != nil {
			postAuthor, _ := r.UserRepo.GetByID(ctx, post.AuthorID)
			postAuthorPublic = mapUserToPublic(postAuthor)
			group, _ = r.CommunityRepo.GetGroupByID(ctx, post.GroupID)
			if group != nil {
				groupOwner, _ := r.UserRepo.GetByID(ctx, group.OwnerID)
				groupOwnerPublic = mapUserToPublic(groupOwner)
			}
		}

		resultMap[c.ID] = mapCommentToModel(c, authorPublic, post, postAuthorPublic, group, groupOwnerPublic)
	}

	// Reconstruct list in order
	var results []model.CommunityResult
	for _, hit := range hits {
		if res, ok := resultMap[hit.ID]; ok {
			results = append(results, res)
		}
	}

	return results, nil
}
